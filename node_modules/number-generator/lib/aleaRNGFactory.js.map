{"version":3,"file":"aleaRNGFactory.js.map","sources":["../src/fns/aleaRNGFactory.js","../src/utils.js"],"sourcesContent":["/** @module number-generator/lib/aleaRNGFactory */\nimport { throwInvalidAleaSeed } from \"../utils\";\n\n/**\n * Number generator with Alea algorithm.\n *\n * From {@link http://baagoe.com/en/RandomMusings/javascript/}\n * Johannes Baag√∏e <baagoe@baagoe.com>, 2010\n * Refactored and extended from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/aleaRNGFactory\n * @param {number} [initialSeed=1] Optional start seed number\n * @return {NumberGenerator} A number generator object\n */\nexport default (() => {\n  /**\n   * Number generator state\n   *\n   * @global\n   * @namespace NumberGeneratorState\n   * @property {number} correction Alea correction value\n   * @property {number[]} sequence An 3-length array of sequences for generating numbers\n   */\n\n  /**\n   * @global\n   * @namespace NumberGenerator\n   */\n\n  /**\n   * Set a seed for the generator\n   *\n   * @function setSeed\n   * @memberof NumberGenerator\n   * @param {number} seed The start seed to use for number generation\n   * @return {number} Returns the defined seed\n   */\n\n  /**\n   * Get an unsigned 32 bit float\n   *\n   * @function uFloat32\n   * @memberof NumberGenerator\n   * @return {number} Returns an unsigned 32 bit float\n   */\n\n  /**\n   * Get an unsigned 32 bit integer\n   *\n   * @function uInt32\n   * @memberof NumberGenerator\n   * @return {number} Returns an unsigned 32 bit integer\n   */\n\n  /**\n   * Returns the current number generator state\n   *\n   * @function getState\n   * @memberof NumberGenerator\n   * @return {NumberGeneratorState} Returns the internal number generator state\n   */\n\n  /**\n   * Set a new number generator state\n   *\n   * @function setState\n   * @memberof NumberGenerator\n   * @param {NumberGeneratorState} [state={correction: 1, sequence: [0, 0, 0]}] A pre configured state object\n   */\n\n  const CORRECTION_DEFAULT = 1;\n  const START_SEQUENCE_0 = 0;\n  const START_SEQUENCE_1 = 0;\n  const START_SEQUENCE_2 = 0;\n  const FRACTURE_FLOAT = 2 ** -32;\n  const FRACTURE_INT = 2 ** 32;\n  const TERM = 2091639;\n  const MULTIPLIER = 69069;\n\n  /**\n   * Number generator with Alea algorithm\n   *\n   * @param {number} [initialSeed=1] Optional start seed number\n   * @return {NumberGenerator} A number generator object\n   */\n  function aleaRNGFactory(initialSeed) {\n    let correction = CORRECTION_DEFAULT;\n    let sequence0 = START_SEQUENCE_0;\n    let sequence1 = START_SEQUENCE_1;\n    let sequence2 = START_SEQUENCE_2;\n\n    /**\n     * Set the used seed number\n     *\n     * @throws {TypeError} Throws an exception if seed is float or negative\n     * @param {number} seed A number value\n     * @return {number} The used number value\n     */\n    function setSeed(seed) {\n      throwInvalidAleaSeed(seed);\n\n      sequence0 = (seed >>> 0) * FRACTURE_FLOAT;\n      seed = (seed * MULTIPLIER + 1) >>> 0;\n      sequence1 = seed * FRACTURE_FLOAT;\n      seed = (seed * MULTIPLIER + 1) >>> 0;\n      sequence2 = seed * FRACTURE_FLOAT;\n      correction = CORRECTION_DEFAULT;\n\n      return seed;\n    }\n\n    /**\n     * Returns a generated random unsigned float number\n     *\n     * @return {number} Generated number\n     */\n    function uFloat32() {\n      const singleTerm = TERM * sequence0 + correction * FRACTURE_FLOAT;\n      correction = singleTerm | 0;\n      sequence0 = sequence1;\n      sequence1 = sequence2;\n      sequence2 = singleTerm - correction;\n      return sequence2;\n    }\n\n    /**\n     * Returns a generated random unsigned 32 integer\n     *\n     * @return {number} Generated number\n     */\n    function uInt32() {\n      return (uFloat32() * FRACTURE_INT) >>> 0;\n    }\n\n    /**\n     * Get the internal sequence state\n     *\n     * @return {NumberGeneratorState} An object defining the internal state\n     */\n    function getState() {\n      return {\n        correction,\n        sequence: [sequence0, sequence1, sequence2],\n      };\n    }\n\n    /**\n     * Set the internal sequence state\n     *\n     * @param {NumberGeneratorState} [state={correction: 1, sequence: [0, 0, 0]}] An object defining the internal state\n     */\n    function setState(state) {\n      const defaultState = {\n        correction: CORRECTION_DEFAULT,\n        sequence: [START_SEQUENCE_0, START_SEQUENCE_1, START_SEQUENCE_2],\n      };\n\n      state = state || defaultState;\n      state.sequence = state.sequence || [];\n\n      correction = state.correction || CORRECTION_DEFAULT;\n      sequence0 = state.sequence[0] || START_SEQUENCE_0;\n      sequence1 = state.sequence[1] || START_SEQUENCE_1;\n      sequence2 = state.sequence[2] || START_SEQUENCE_2;\n    }\n\n    setSeed(initialSeed === undefined ? 1 : initialSeed);\n\n    return { setSeed, uFloat32, uInt32, getState, setState };\n  }\n\n  return aleaRNGFactory;\n})();\n","/**\n * Returns a multiple unsigned int32\n *\n * @private\n * @param {number} x Non linear base\n * @param {number} y Linear base\n * @return {number} Unsigned int32\n */\nexport function uMul32Getter(x, y) {\n  x = x | 0;\n  y = y | 0;\n  const nonLinear = x & 0xffff;\n  const linearBase = x >>> 16;\n\n  return (nonLinear * y + (((linearBase * y) & 0xffff) << 16)) | 0;\n}\n\n/**\n * Return an unsigned int32 from hash by position\n *\n * @private\n * @param {Uint8Array} bytes UTF8 string as array\n * @param {number} position String start position\n * @return {number} Unsigned int32\n */\nexport function uInt32Getter(bytes, position) {\n  return (\n    bytes[position++] +\n    (bytes[position++] << 8) +\n    (bytes[position++] << 16) +\n    (bytes[position++] << 24)\n  );\n}\n\n/**\n * Mix hash for x86\n *\n * @private\n * @param {number} hash Base number hash\n * @returns {number} Mixed number hash\n */\nexport function uInt32mix(hash) {\n  hash ^= hash >>> 16;\n  hash = uMul32Getter(hash, 0x85ebca6b);\n  hash ^= hash >>> 13;\n  hash = uMul32Getter(hash, 0xc2b2ae35);\n  hash ^= hash >>> 16;\n\n  return hash;\n}\n\n/**\n * Returns the int32 rotated left by the number of positions\n *\n * @private\n * @param {number} x Unsigned int32\n * @param {number} y Number representing bit positions\n * @returns {number}\n */\nexport function uInt32RotateLeft(x, y) {\n  return (x << y) | (x >>> (32 - y));\n}\n\n/**\n * Create concated and filled hash string\n *\n * @private\n * @param {number[]} hash Array containing hash parts as int, represented as tuple of 4\n * @returns {string} Concatenated and filled hash\n */\nexport function createConcatenatedHash([h1, h2, h3, h4]) {\n  const fill = \"00000000\";\n  return (\n    (fill + (h1 >>> 0).toString(16)).slice(-8) +\n    (fill + (h2 >>> 0).toString(16)).slice(-8) +\n    (fill + (h3 >>> 0).toString(16)).slice(-8) +\n    (fill + (h4 >>> 0).toString(16)).slice(-8)\n  );\n}\n\n/**\n * Throw an error if the given seed is invalid for a murmur hash algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidMurmurSeed(seed) {\n  if (seed !== undefined && seed % 1 !== 0) {\n    throw new TypeError(\"Expected seed to be an integer, float given\");\n  }\n}\n\n/**\n * Throw an error if the given seed is invalid for the alea algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidAleaSeed(seed) {\n  if (seed % 1 !== 0 || seed <= 0) {\n    throw new TypeError(\n      `Expected seed to be an unsigned integer greater or equal 1, but got \"${seed}\"`\n    );\n  }\n}\n\n/**\n * Throw an error if a given hash is not a string\n *\n * @private\n * @param {string} hash The possible empty hash value\n * @param {string} functionName A function name to enhance the error message\n */\nexport function throwInvalidStringHash(hash, functionName) {\n  if (typeof hash !== \"string\") {\n    throw new TypeError(`${functionName}(): first argument is not a string.`);\n  }\n}\n\n/**\n * Encode non regular ASCII characters in string to array of chars\n *\n * @private\n * @param {string} str Encode a string into a Uint8 array\n * @returns {Uint8Array}\n */\nfunction encode(str) {\n  const length = str.length;\n  let resPos = -1;\n\n  // The Uint8Array's length must be at least 3x the length of the string because an invalid UTF-16\n  // takes up the equivalent space of 3 UTF-8 characters to encode it properly. However, Array's\n  // have an auto expanding length and 1.5x should be just the right balance for most uses.\n  const resultArray = new Uint8Array(length * 3);\n  let i = 0;\n\n  while (i !== length) {\n    let point = str.charCodeAt(i);\n    i += 1;\n\n    if (point >= 0xd800 && point <= 0xdbff) {\n      if (i === length) {\n        resultArray[(resPos += 1)] = 0xef; // 0b11101111\n        resultArray[(resPos += 1)] = 0xbf; // 0b10111111\n        resultArray[(resPos += 1)] = 0xbd; // 0b10111101\n        break;\n      }\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      const nextCode = str.charCodeAt(i);\n\n      if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {\n        point = (point - 0xd800) * 0x400 + nextCode - 0xdc00 + 0x10000;\n        i += 1;\n\n        if (point > 0xffff) {\n          // point > 65535\n          resultArray[(resPos += 1)] = (0x1e /*0b11110*/ << 3) | (point >>> 18);\n          resultArray[(resPos += 1)] =\n            (0x2 /*0b10*/ << 6) | ((point >>> 12) & 0x3f); // 0b00111111\n          resultArray[(resPos += 1)] =\n            (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f); // 0b00111111\n          resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n          continue;\n        }\n      } else {\n        resultArray[(resPos += 1)] = 0xef; // 0b11101111\n        resultArray[(resPos += 1)] = 0xbf; // 0b10111111\n        resultArray[(resPos += 1)] = 0xbd; // 0b10111101\n        continue;\n      }\n    }\n\n    if (point <= 0x007f) {\n      resultArray[(resPos += 1)] = (0x0 /*0b0*/ << 7) | point;\n    } else if (point <= 0x07ff) {\n      resultArray[(resPos += 1)] = (0x6 /*0b110*/ << 5) | (point >>> 6);\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n    } else {\n      resultArray[(resPos += 1)] = (0xe /*0b1110*/ << 4) | (point >>> 12);\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f); // 0b00111111\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n    }\n  }\n\n  return resultArray.subarray(0, resPos + 1);\n}\n\n/**\n * Convert string to array of UTF 8 bytes\n *\n * @private\n * @param {string} str String to convert\n * @returns {Uint8Array} Encoded UTF8 chars\n */\nexport function toUtf8Bytes(str) {\n  const result = new Uint8Array(str.length);\n\n  for (let i = 0; i < str.length; i += 1) {\n    const charCode = str.charCodeAt(i);\n    if (charCode < 0 || charCode > 127) {\n      return encode(str);\n    }\n    result[i] = charCode;\n  }\n\n  return result;\n}\n"],"names":["FRACTURE_FLOAT","FRACTURE_INT","aleaRNGFactory","Math","pow","initialSeed","correction","sequence0","sequence1","sequence2","setSeed","seed","TypeError","throwInvalidAleaSeed","uFloat32","singleTerm","undefined","uInt32","getState","sequence","setState","state"],"mappings":"aAcA,IA4DQA,EACAC,EA7DRC,GA4DQF,EAAiBG,KAAAC,IAAA,GAAM,IACvBH,EAAYE,KAAAC,IAAG,EAAK,IAU1B,SAAwBC,GACtB,IAAIC,EAhBqB,EAiBrBC,EAhBmB,EAiBnBC,EAhBmB,EAiBnBC,EAhBmB,EAyBvB,SAASC,EAAQC,GAUf,OCVC,SAA8BA,GACnC,GAAIA,EAAO,GAAM,GAAKA,GAAQ,EAC5B,MAAM,IAAIC,UACgED,wEAAAA,OAAAA,EAD1E,MDDEE,CAAqBF,GAErBJ,GAAaI,IAAS,GAAKX,EAE3BQ,GADAG,EAzBe,MAyBPA,EAAoB,IAAO,GAChBX,EAEnBS,GADAE,EA3Be,MA2BPA,EAAoB,IAAO,GAChBX,EACnBM,EApCuB,EAsChBK,EAQT,SAASG,IACP,IAAMC,EAzCG,QAyCiBR,EAAYD,EAAaN,EAKnD,OAHAO,EAAYC,EACZA,EAAYC,EACZA,EAAYM,GAHZT,EAA0B,EAAbS,GAkDf,OAFAL,OAAwBM,IAAhBX,EAA4B,EAAIA,GAEjC,CAAEK,QAAAA,EAASI,SAAAA,EAAUG,OAtC5B,WACE,OAAQH,IAAab,IAAkB,GAqCLiB,SA7BpC,WACE,MAAO,CACLZ,WAAAA,EACAa,SAAU,CAACZ,EAAWC,EAAWC,KA0BSW,SAjB9C,SAAkBC,IAMhBA,EAAQA,GALa,CACnBf,WAnFqB,EAoFrBa,SAAU,CAnFS,EACA,EACA,KAqFfA,SAAWE,EAAMF,UAAY,GAEnCb,EAAae,EAAMf,YA1FI,EA2FvBC,EAAYc,EAAMF,SAAS,IA1FN,EA2FrBX,EAAYa,EAAMF,SAAS,IA1FN,EA2FrBV,EAAYY,EAAMF,SAAS,IA1FN"}