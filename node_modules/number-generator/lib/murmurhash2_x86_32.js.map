{"version":3,"file":"murmurhash2_x86_32.js.map","sources":["../src/utils.js","../src/fns/murmurhash2_x86_32.js"],"sourcesContent":["/**\n * Returns a multiple unsigned int32\n *\n * @private\n * @param {number} x Non linear base\n * @param {number} y Linear base\n * @return {number} Unsigned int32\n */\nexport function uMul32Getter(x, y) {\n  x = x | 0;\n  y = y | 0;\n  const nonLinear = x & 0xffff;\n  const linearBase = x >>> 16;\n\n  return (nonLinear * y + (((linearBase * y) & 0xffff) << 16)) | 0;\n}\n\n/**\n * Return an unsigned int32 from hash by position\n *\n * @private\n * @param {Uint8Array} bytes UTF8 string as array\n * @param {number} position String start position\n * @return {number} Unsigned int32\n */\nexport function uInt32Getter(bytes, position) {\n  return (\n    bytes[position++] +\n    (bytes[position++] << 8) +\n    (bytes[position++] << 16) +\n    (bytes[position++] << 24)\n  );\n}\n\n/**\n * Mix hash for x86\n *\n * @private\n * @param {number} hash Base number hash\n * @returns {number} Mixed number hash\n */\nexport function uInt32mix(hash) {\n  hash ^= hash >>> 16;\n  hash = uMul32Getter(hash, 0x85ebca6b);\n  hash ^= hash >>> 13;\n  hash = uMul32Getter(hash, 0xc2b2ae35);\n  hash ^= hash >>> 16;\n\n  return hash;\n}\n\n/**\n * Returns the int32 rotated left by the number of positions\n *\n * @private\n * @param {number} x Unsigned int32\n * @param {number} y Number representing bit positions\n * @returns {number}\n */\nexport function uInt32RotateLeft(x, y) {\n  return (x << y) | (x >>> (32 - y));\n}\n\n/**\n * Create concated and filled hash string\n *\n * @private\n * @param {number[]} hash Array containing hash parts as int, represented as tuple of 4\n * @returns {string} Concatenated and filled hash\n */\nexport function createConcatenatedHash([h1, h2, h3, h4]) {\n  const fill = \"00000000\";\n  return (\n    (fill + (h1 >>> 0).toString(16)).slice(-8) +\n    (fill + (h2 >>> 0).toString(16)).slice(-8) +\n    (fill + (h3 >>> 0).toString(16)).slice(-8) +\n    (fill + (h4 >>> 0).toString(16)).slice(-8)\n  );\n}\n\n/**\n * Throw an error if the given seed is invalid for a murmur hash algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidMurmurSeed(seed) {\n  if (seed !== undefined && seed % 1 !== 0) {\n    throw new TypeError(\"Expected seed to be an integer, float given\");\n  }\n}\n\n/**\n * Throw an error if the given seed is invalid for the alea algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidAleaSeed(seed) {\n  if (seed % 1 !== 0 || seed <= 0) {\n    throw new TypeError(\n      `Expected seed to be an unsigned integer greater or equal 1, but got \"${seed}\"`\n    );\n  }\n}\n\n/**\n * Throw an error if a given hash is not a string\n *\n * @private\n * @param {string} hash The possible empty hash value\n * @param {string} functionName A function name to enhance the error message\n */\nexport function throwInvalidStringHash(hash, functionName) {\n  if (typeof hash !== \"string\") {\n    throw new TypeError(`${functionName}(): first argument is not a string.`);\n  }\n}\n\n/**\n * Encode non regular ASCII characters in string to array of chars\n *\n * @private\n * @param {string} str Encode a string into a Uint8 array\n * @returns {Uint8Array}\n */\nfunction encode(str) {\n  const length = str.length;\n  let resPos = -1;\n\n  // The Uint8Array's length must be at least 3x the length of the string because an invalid UTF-16\n  // takes up the equivalent space of 3 UTF-8 characters to encode it properly. However, Array's\n  // have an auto expanding length and 1.5x should be just the right balance for most uses.\n  const resultArray = new Uint8Array(length * 3);\n  let i = 0;\n\n  while (i !== length) {\n    let point = str.charCodeAt(i);\n    i += 1;\n\n    if (point >= 0xd800 && point <= 0xdbff) {\n      if (i === length) {\n        resultArray[(resPos += 1)] = 0xef; // 0b11101111\n        resultArray[(resPos += 1)] = 0xbf; // 0b10111111\n        resultArray[(resPos += 1)] = 0xbd; // 0b10111101\n        break;\n      }\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      const nextCode = str.charCodeAt(i);\n\n      if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {\n        point = (point - 0xd800) * 0x400 + nextCode - 0xdc00 + 0x10000;\n        i += 1;\n\n        if (point > 0xffff) {\n          // point > 65535\n          resultArray[(resPos += 1)] = (0x1e /*0b11110*/ << 3) | (point >>> 18);\n          resultArray[(resPos += 1)] =\n            (0x2 /*0b10*/ << 6) | ((point >>> 12) & 0x3f); // 0b00111111\n          resultArray[(resPos += 1)] =\n            (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f); // 0b00111111\n          resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n          continue;\n        }\n      } else {\n        resultArray[(resPos += 1)] = 0xef; // 0b11101111\n        resultArray[(resPos += 1)] = 0xbf; // 0b10111111\n        resultArray[(resPos += 1)] = 0xbd; // 0b10111101\n        continue;\n      }\n    }\n\n    if (point <= 0x007f) {\n      resultArray[(resPos += 1)] = (0x0 /*0b0*/ << 7) | point;\n    } else if (point <= 0x07ff) {\n      resultArray[(resPos += 1)] = (0x6 /*0b110*/ << 5) | (point >>> 6);\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n    } else {\n      resultArray[(resPos += 1)] = (0xe /*0b1110*/ << 4) | (point >>> 12);\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f); // 0b00111111\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n    }\n  }\n\n  return resultArray.subarray(0, resPos + 1);\n}\n\n/**\n * Convert string to array of UTF 8 bytes\n *\n * @private\n * @param {string} str String to convert\n * @returns {Uint8Array} Encoded UTF8 chars\n */\nexport function toUtf8Bytes(str) {\n  const result = new Uint8Array(str.length);\n\n  for (let i = 0; i < str.length; i += 1) {\n    const charCode = str.charCodeAt(i);\n    if (charCode < 0 || charCode > 127) {\n      return encode(str);\n    }\n    result[i] = charCode;\n  }\n\n  return result;\n}\n","/** @module number-generator/lib/murmurhash2_x86_32 */\nimport {\n  uMul32Getter,\n  uInt32Getter,\n  throwInvalidMurmurSeed,\n  throwInvalidStringHash,\n  toUtf8Bytes,\n} from \"../utils\";\n\n/**\n * Generate a non-cryptic 32 bit number hash for x86 with murmur2 algorithm.\n *\n * From {@link https://gist.github.com/raycmorgan/588423}\n * Ray Morgan, 2011\n * Refactored and extended including fixes for edge cases from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/murmurhash2_x86_32\n * @throws {TypeError} Throws an exception if hash is not a string\n * @throws {TypeError} Throws an exception if seed is a float\n * @param {string} str The base string hash to generate number\n * @param {number} [seed=0] An optional seed value\n * @return {number} Generated number\n */\nexport default (() => {\n  const MULTIPLIER = 0x5bd1e995;\n  const BASE = 24;\n\n  /**\n   * Return an unsigned int16 from hash by position\n   *\n   * @private\n   * @param {Uint8Array} hash String hash value\n   * @param {number} position String start position\n   * @return {number} Unsigned int16\n   */\n  const uInt16Getter = (hash, position) =>\n    hash[position++] + (hash[position] << 8);\n\n  /**\n   * Generate a non-cryptic 32 bit number hash for x86 with murmur2 algorithm.\n   *\n   * @throws {TypeError} Throws an exception if hash is not a string\n   * @throws {TypeError} Throws an exception if seed is a float\n   * @param {string} str The base string hash to generate number\n   * @param {number} [seed=0] An optional seed value\n   * @return {number} Generated number\n   */\n  function murmurhash2_x86_32(str, seed = 0) {\n    throwInvalidStringHash(str, \"murmurhash2_x86_32\");\n    throwInvalidMurmurSeed(seed);\n\n    const hash = toUtf8Bytes(str);\n    let currentIndex = 0;\n    let hashSum = seed ^ hash.length;\n    let length = hash.length;\n\n    while (length >= 4) {\n      let calculated = uInt32Getter(hash, currentIndex);\n\n      calculated = uMul32Getter(calculated, MULTIPLIER);\n      calculated ^= calculated >>> BASE;\n      calculated = uMul32Getter(calculated, MULTIPLIER);\n\n      hashSum = uMul32Getter(hashSum, MULTIPLIER);\n      hashSum ^= calculated;\n\n      currentIndex += 4;\n      length -= 4;\n    }\n\n    switch (length) {\n      case 3:\n        hashSum ^= uInt16Getter(hash, currentIndex);\n        hashSum ^= hash[currentIndex + 2] << 16;\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        break;\n      case 2:\n        hashSum ^= uInt16Getter(hash, currentIndex);\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        break;\n      case 1:\n        hashSum ^= hash[currentIndex];\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        break;\n    }\n\n    hashSum ^= hashSum >>> 13;\n    hashSum = uMul32Getter(hashSum, MULTIPLIER);\n    hashSum ^= hashSum >>> 15;\n\n    return hashSum >>> 0;\n  }\n\n  return murmurhash2_x86_32;\n})();\n"],"names":["uMul32Getter","x","y","uInt32Getter","bytes","position","throwInvalidMurmurSeed","seed","undefined","TypeError","throwInvalidStringHash","hash","functionName","encode","str","length","resPos","resultArray","Uint8Array","i","point","charCodeAt","nextCode","subarray","toUtf8Bytes","result","charCode","MULTIPLIER","uInt16Getter","murmurhash2_x86_32","currentIndex","hashSum","calculated"],"mappings":"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"}